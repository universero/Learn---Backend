> [[大话设计模式.pdf#page=412&selection=22,0,25,1|享元模式]]
## 核心思想

 > 运用共享技术有效地支持大量细粒度的对 象。
 
 - 抽象享元（Flyweight）角色：定义了享元对象的基本接口，使这些对象可以相互替换。
- 具体享元（ConcreteFlyweight）角色：实现抽象享元接口，并为内部状态提供存储空间。
- 非享元（UnsharedConcreteFlyweight）角色：不需要共享的享元子类可以设计为非共享的享元。
- 享元工厂（FlyweightFactory）角色：负责创建和管理享元对象，确保享元对象可以被系统适当地共享。
## 优势

1. 减少内存消耗：享元模式通过共享对象来减少内存的使用，对于大量细粒度对象的情况，可以显著提高内存使用效率。
2. 提高性能：由于减少了对象的数量，可以提高系统的性能，尤其是在对象创建和销毁成本较高的情况下。
3. 提高系统的可扩展性：由于享元模式将内部状态和外部状态分离，因此可以更容易地增加新的享元对象，而不会影响外部状态。
## 缺陷

1. 模式复杂度增加：享元模式需要分离内部状态和外部状态，这可能会增加系统的复杂度。
2. 系统设计难度提升：需要仔细设计享元对象和工厂类，以确保正确地共享对象，这可能需要额外的设计和实现工作。
3. 可能导致线程安全问题：如果享元对象被多个线程共享，那么需要确保享元对象的线程安全。
## UML

![[享元模式.png]]
## 场景

>在享元对象内部并且不会随环境改变而改变的共享部分，可以称为享元对象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态 了。事实上，享元模式可以避免大量非常相似类的开销。在程序设计中，有 时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个 参数外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数 量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来， 就可以通过共享大幅度地减少单个实例的数目 