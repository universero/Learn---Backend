## 核心思想

> 定义了一族算法，分别封装起来，算法间可以相互替换，此模式让算法的变化不会影响到算法的客户

- 抽象类：策略类，Strategy，定义所有支持的算法的公共接口
- 实现类：具体策略类，封装了具体的算法或行为，继承Strategy
- 上下文：Context，用具体策略类配置，维护对一个Strategy对象的引用，用于管理策略
## 优势

- 灵活：可以动态改变策略，只需要用不同的策略类构造上下文
- 易于扩展：添加新的策略时，只需要增加一个新的策略类即可，符合开放/封闭原则
- 简化了单元测试：每个算法都有单独类，可以单独测试接口
- **策略模式封装了变化**，避免了大量的条件判断
## 缺陷

- 需要客户端使用各种策略，增加了耦合性
- 具体策略过多时难以管理
## UML
![[策略模式.png]]
## 场景

### 商品折扣

计算折扣时有 不折扣、比例折扣、满减等多种可能

若使用工厂模式，每次收费方式更改都需要修改工厂类

使用策略模式，CashContext管理折扣策略，具体策略类实现折扣策略，用户通过不同的具体策略类构造CashContext
但是仍存在一个问题，策略的选择逻辑又交由客户端实现，增加了复杂度

可以使用工厂和策略组合的模式，Context中内置选择逻辑构造不同的Context，但这样又会导致增加策略时需要修改Context降低了扩展性
