## 单一职责原则

>**就一个类而言，应该仅有一个引起它变化的原因**
>
>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏

## 开放-封闭原则

>**对扩展开放，对修改封闭**
>
>软件实体应该可扩展，但是不可修改
>
>无 论 模 块 是 多 么 的'封闭'，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化
>
>变化发生时，立即采取行动，创建抽象来隔离以后发生的同类变化

## 依赖倒置原则

>**高层模块不应该依赖底层模块，两个都应该依赖抽象**
>**抽象不依赖于细节，细节应该依赖于抽象**
>
>针对接口编程而不是针对实现编程

## 里氏代换原则 (LSP)

> **子类型必须能够替换掉其父类型**
> 
> 只有当子类可以替换 掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能 够在父类的基础上增加新的行为
> 
> 依赖倒转其实可以说是面向对象设计的标志，用哪种语言 来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细 节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向 对象的设计，反之那就是过程化的设计了

![[里氏代换原则.png]]
## 迪米特法则

> 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 
> 
> 类之间的耦合越弱，越有利于复用，一个 处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐 藏促进了软件的复用

每个类都应当尽量降低成员的访问权限

## 组合 / 聚合复用原则

组合 / 聚合优于继承