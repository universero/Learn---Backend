## 55. 跳跃游戏
### 题目描述

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

### 题解

```go
func canJump(nums []int) bool {
	n := len(nums[i])
	max := nums[0]
	for i:=0; i<=max&&i<n; i++ {
	  if nums[i]+i > max {
		  max = nums[i]+i
	  }
	}
	return max>=n-1
}
```

### 问题记录

- 只考虑了i<=max，却忽略了max可能大于总长度
### 知识点

## 121. 买股票的最好时机

### 题目描述

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
### 题解

```go
func maxProfit(prices []int) int {
	n := len(prices)
	if n <= 1 {
		return 0
	}
	
	right:= prices[n-1]
	max := 0
	for i:= n-2 ; i>= 0; i++ {
		if right - prices[i] > max {
			max = right - prices[i]
		}
		if right < prices[i] {
			right = prices[i]
		}
	}
	return max
}
```

### 问题记录

- 倒叙遍历数组时，按照惯性写了i++，实际上应该用i--

### 知识点

## #good 122. 买卖股票的最佳时机 II

### 题目描述

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 _你能获得的 **最大** 利润_ 。
### 题解

```go
func maxProfit(prices []int) int {
	ans := 0
	for i:=1; i<len(prices); i++ {
		if (prices[i]>prices[i-1]) {
			ans += prices[i] - prices[i-1]
		}
	}
	return ans
}
```

> 考虑折线图可以发现，收集到所有的上坡一定是最大值。疑虑：如果增长就卖会不会出现其实先亏然后换一只股票再卖赚的更多。虽然单笔不是利润最大，但是从最低到最高小于每个上坡的和

### 问题记录

### 知识点

- 动态规划
```text
考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。

定义状态dp[i][0]表示第i天交易完后手里没有股票的最大利润，dp[i][1]表示第i天交易完后手里持有一支股票的最大利润（i从0开始）。

考虑dp[i][0]的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即dp[i−1][1]，这时候我们要将其卖出，并获得prices[i]的收益。因此为了收益最大化，我们列出如下的转移方程：

dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]}
再来考虑dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即dp[i−1][1]，或者前一天结束时还没有股票，即dp[i−1][0]，这时候我们要将其买入，并减少prices[i]的收益。可以列出如下的转移方程：

dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}
对于初始状态，根据状态定义我们可以知道第0天交易结束的时候dp[0][0]=0，dp[0][1]=−prices[0]。

因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候dp[n−1][0]的收益必然是大于dp[n−1][1]的，最后的答案即为dp[n−1][0]
```

```go
func maxProfit(prices []int) int {
    n := len(prices)
    dp := make([][2]int, n)
    dp[0][1] = -prices[0]
    for i := 1; i < n; i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
    }
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```